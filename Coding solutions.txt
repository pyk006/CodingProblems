LeetCode Problems
1.  Median of Two Arrays : Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.
The overall run time complexity should be O(log (m+n)).

Answer: 
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    //Get the length for the new merged array and create new array
        int mergedLength = nums1.length + nums2.length;
        int[] nums3 = new int[mergedLength];
        //Create copies of nums1 and nums2 and initialize them in your new array
        System.arraycopy(nums1, 0, nums3, 0, nums1.length);  
        System.arraycopy(nums2, 0, nums3, nums1.length, nums2.length); 
        double median = 0;
        Arrays.sort(nums3);
        //Calculate for median when it has one median value or two median values
        if (nums3.length % 2 == 0) {
    median = ((double)nums3[nums3.length/2] + (double)nums3[nums3.length/2 - 1])/2;
} else {
    median = (double) nums3[nums3.length/2];
        return median;
        }
    }
}


2. 3Sum : Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
Notice that the solution set must not contain duplicate triplets.

Answer:
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> listOfTriplets = new ArrayList<>();
        Set<String> checkForDuplicates = new HashSet<>();

        Arrays.sort(nums); // Sort the array to optimize duplicate checks

        for (int i = 0; i < nums.length - 2; i++) {
            int j = i + 1;
            int k = nums.length - 1;

            while (j < k) {
                int sum = nums[i] + nums[j] + nums[k];

                if (sum == 0) {
                    List<Integer> triplet = Arrays.asList(nums[i], nums[j], nums[k]);
                    String tripletString = triplet.toString(); // Convert triplet to a string

                    if (!checkForDuplicates.contains(tripletString)) {
                        checkForDuplicates.add(tripletString);
                        listOfTriplets.add(triplet);
                    }

                    j++;
                    k--;
                } else if (sum < 0) {
                    j++;
                } else {
                    k--;
                }
            }
        }

        return listOfTriplets;
    }
}

3. Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order

class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int j = 1; j < nums.length; j++) {
                if (nums[i] + nums[j] == target && i != j) {
                    return new int[] {i, j};
                }
            }

            }
            return new int[]{0};
        }

    }
    
4. Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.

 class Solution {
    public boolean containsDuplicate(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int num : nums) {
            if (set.contains(num)) {
                return true;
            }
            set.add(num);
        }
        return false;
    }
}
5. Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

class Solution {
    public int strStr(String haystack, String needle) {
        return haystack.indexOf(needle);
    }
}

6. Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.
You must implement a solution with a linear runtime complexity and use only constant extra space.

class Solution {
    public int singleNumber(int[] nums) {
        List<Integer> listNumbers = Arrays.stream(nums)
                .boxed()
                .collect(Collectors.toList());
        for (int i = 0; i < listNumbers.size(); i++) {
            if (listNumbers.indexOf(listNumbers.get(i)) == listNumbers.lastIndexOf(listNumbers.get(i))) {
                return listNumbers.get(i);
            }
        }
        return 0;
    }
}

7. Write a function that takes the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).

public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        String binaryString = Integer.toBinaryString(n);

        String[] binaryStringArr = binaryString.split("");

        return (int) Arrays.stream(binaryStringArr).filter(val -> val.equals("1")).count();
    }
}

8. Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]). Return the running sum of nums.

class Solution {
    public int[] runningSum(int[] nums) {
        int a = 0;
        int[] sums = new int[nums.length];
        for (int i = 0; i < nums.length; i++) {
            sums[i] = a + nums[i];
            a = a + nums[i];
        }
        return sums;
    }
}

9. There is a programming language with only four operations and one variable X:

++X and X++ increments the value of the variable X by 1.
--X and X-- decrements the value of the variable X by 1.
Initially, the value of X is 0.

Given an array of strings operations containing a list of operations, return the final value of X after performing all the operations.

class Solution {
    public int finalValueAfterOperations(String[] operations) {
        int count = 0;
        for (int i = 0; i < operations.length; i++) {
            if (operations[i].contains("--")) {
                count -=1;
            } else {
                count +=1;
            }
        }
        return count;
    }
}

10. Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's such that j != i and nums[j] < nums[i].
Return the answer in an array.

class Solution {
    public int[] smallerNumbersThanCurrent(int[] nums) {
        int[] numSmalls = new int[nums.length];
        int count = 0;
        for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j < nums.length; j++) {
                if (nums[i] > nums[j]) {
                    count+=1;
                }
            }
            numSmalls[i] = count;
            count = 0;
        }
        return numSmalls;
    }
}

11. There are n kids with candies. You are given an integer array candies, where each candies[i] represents the number of candies the ith kid has, and an integer extraCandies, denoting the number of extra candies that you have.
Return a boolean array result of length n, where result[i] is true if, after giving the ith kid all the extraCandies, they will have the greatest number of candies among all the kids, or false otherwise.
Note that multiple kids can have the greatest number of candies.

class Solution {
    public List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {
        List<Boolean> listOfLargest = new ArrayList<>();
        int max = Arrays.stream(candies).max().orElse(0);
        for (int i = 0; i < candies.length; i++) {
            if (candies[i] + extraCandies >= max) {
                listOfLargest.add(true);
            } else {
                listOfLargest.add(false);
            }
        }
        return listOfLargest;
    }
}

12. You are given an m x n integer grid accounts where accounts[i][j] is the amount of money the i​​​​​​​​​​​th​​​​ customer has in the j​​​​​​​​​​​th​​​​ bank. Return the wealth that the richest customer has.
A customer's wealth is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum wealth.

class Solution {
    public int maximumWealth(int[][] accounts) {
        List<Integer> listOfAccounts = new ArrayList<>();
        for (int[] account : accounts) {
            listOfAccounts.add(Arrays.stream(account).reduce((a,b) -> a + b).orElse(0));
        }
        return Collections.max(listOfAccounts);
    }
}

13. You are given two positive integers n and k. A factor of an integer n is defined as an integer i where n % i == 0.
Consider a list of all factors of n sorted in ascending order, return the kth factor in this list or return -1 if n has less than k factors.

class Solution {
    public int kthFactor(int n, int k) {
        List<Integer>listOfFactors = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            if (n % i == 0) {
                listOfFactors.add(i);
            }
        }
            if (k > listOfFactors.size()) {
                return -1; // k is out of bounds
        }
         return listOfFactors.get(k - 1);
    }
}
