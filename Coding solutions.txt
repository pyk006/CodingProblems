LeetCode Problems
1.  Median of Two Arrays : Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.
The overall run time complexity should be O(log (m+n)).

Answer: 
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    //Get the length for the new merged array and create new array
        int mergedLength = nums1.length + nums2.length;
        int[] nums3 = new int[mergedLength];
        //Create copies of nums1 and nums2 and initialize them in your new array
        System.arraycopy(nums1, 0, nums3, 0, nums1.length);  
        System.arraycopy(nums2, 0, nums3, nums1.length, nums2.length); 
        double median = 0;
        Arrays.sort(nums3);
        //Calculate for median when it has one median value or two median values
        if (nums3.length % 2 == 0) {
    median = ((double)nums3[nums3.length/2] + (double)nums3[nums3.length/2 - 1])/2;
} else {
    median = (double) nums3[nums3.length/2];
        return median;
        }
    }
}


2. 3Sum : Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
Notice that the solution set must not contain duplicate triplets.

Answer:
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> listOfTriplets = new ArrayList<>();
        Set<String> checkForDuplicates = new HashSet<>();

        Arrays.sort(nums); // Sort the array to optimize duplicate checks

        for (int i = 0; i < nums.length - 2; i++) {
            int j = i + 1;
            int k = nums.length - 1;

            while (j < k) {
                int sum = nums[i] + nums[j] + nums[k];

                if (sum == 0) {
                    List<Integer> triplet = Arrays.asList(nums[i], nums[j], nums[k]);
                    String tripletString = triplet.toString(); // Convert triplet to a string

                    if (!checkForDuplicates.contains(tripletString)) {
                        checkForDuplicates.add(tripletString);
                        listOfTriplets.add(triplet);
                    }

                    j++;
                    k--;
                } else if (sum < 0) {
                    j++;
                } else {
                    k--;
                }
            }
        }

        return listOfTriplets;
    }
}

3. Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order

class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int j = 1; j < nums.length; j++) {
                if (nums[i] + nums[j] == target && i != j) {
                    return new int[] {i, j};
                }
            }

            }
            return new int[]{0};
        }

    }
    
4. Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.

 class Solution {
    public boolean containsDuplicate(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int num : nums) {
            if (set.contains(num)) {
                return true;
            }
            set.add(num);
        }
        return false;
    }
}
5. Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

class Solution {
    public int strStr(String haystack, String needle) {
        return haystack.indexOf(needle);
    }
}

6. Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.
You must implement a solution with a linear runtime complexity and use only constant extra space.

class Solution {
    public int singleNumber(int[] nums) {
        List<Integer> listNumbers = Arrays.stream(nums)
                .boxed()
                .collect(Collectors.toList());
        for (int i = 0; i < listNumbers.size(); i++) {
            if (listNumbers.indexOf(listNumbers.get(i)) == listNumbers.lastIndexOf(listNumbers.get(i))) {
                return listNumbers.get(i);
            }
        }
        return 0;
    }
}

7. Write a function that takes the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).

public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        String binaryString = Integer.toBinaryString(n);

        String[] binaryStringArr = binaryString.split("");

        return (int) Arrays.stream(binaryStringArr).filter(val -> val.equals("1")).count();
    }
}

8. Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]). Return the running sum of nums.

class Solution {
    public int[] runningSum(int[] nums) {
        int a = 0;
        int[] sums = new int[nums.length];
        for (int i = 0; i < nums.length; i++) {
            sums[i] = a + nums[i];
            a = a + nums[i];
        }
        return sums;
    }
}

9. There is a programming language with only four operations and one variable X:

++X and X++ increments the value of the variable X by 1.
--X and X-- decrements the value of the variable X by 1.
Initially, the value of X is 0.

Given an array of strings operations containing a list of operations, return the final value of X after performing all the operations.

class Solution {
    public int finalValueAfterOperations(String[] operations) {
        int count = 0;
        for (int i = 0; i < operations.length; i++) {
            if (operations[i].contains("--")) {
                count -=1;
            } else {
                count +=1;
            }
        }
        return count;
    }
}

10. Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's such that j != i and nums[j] < nums[i].
Return the answer in an array.

class Solution {
    public int[] smallerNumbersThanCurrent(int[] nums) {
        int[] numSmalls = new int[nums.length];
        int count = 0;
        for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j < nums.length; j++) {
                if (nums[i] > nums[j]) {
                    count+=1;
                }
            }
            numSmalls[i] = count;
            count = 0;
        }
        return numSmalls;
    }
}

11. There are n kids with candies. You are given an integer array candies, where each candies[i] represents the number of candies the ith kid has, and an integer extraCandies, denoting the number of extra candies that you have.
Return a boolean array result of length n, where result[i] is true if, after giving the ith kid all the extraCandies, they will have the greatest number of candies among all the kids, or false otherwise.
Note that multiple kids can have the greatest number of candies.

class Solution {
    public List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {
        List<Boolean> listOfLargest = new ArrayList<>();
        int max = Arrays.stream(candies).max().orElse(0);
        for (int i = 0; i < candies.length; i++) {
            if (candies[i] + extraCandies >= max) {
                listOfLargest.add(true);
            } else {
                listOfLargest.add(false);
            }
        }
        return listOfLargest;
    }
}

12. You are given an m x n integer grid accounts where accounts[i][j] is the amount of money the i​​​​​​​​​​​th​​​​ customer has in the j​​​​​​​​​​​th​​​​ bank. Return the wealth that the richest customer has.
A customer's wealth is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum wealth.

class Solution {
    public int maximumWealth(int[][] accounts) {
        List<Integer> listOfAccounts = new ArrayList<>();
        for (int[] account : accounts) {
            listOfAccounts.add(Arrays.stream(account).reduce((a,b) -> a + b).orElse(0));
        }
        return Collections.max(listOfAccounts);
    }
}

13. You are given two positive integers n and k. A factor of an integer n is defined as an integer i where n % i == 0.
Consider a list of all factors of n sorted in ascending order, return the kth factor in this list or return -1 if n has less than k factors.

class Solution {
    public int kthFactor(int n, int k) {
        List<Integer>listOfFactors = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            if (n % i == 0) {
                listOfFactors.add(i);
            }
        }
            if (k > listOfFactors.size()) {
                return -1; // k is out of bounds
        }
         return listOfFactors.get(k - 1);
    }
}

14. Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.

class Solution {
 public static int addDigits(int num) {
        String[] nums = String.valueOf(num).split("");
        while (nums.length > 1) {
            nums = String.valueOf(Arrays.stream(nums).mapToInt(numInArr -> Integer.parseInt(numInArr)).sum()).split("");
        }
        return Integer.parseInt(String.join("", nums));
    }
}

15. Given a positive integer num, return true if num is a perfect square or false otherwise.
A perfect square is an integer that is the square of an integer. In other words, it is the product of some integer with itself.
You must not use any built-in library function, such as sqrt.

class Solution {
    public boolean isPerfectSquare(int num) {

        for (int i = 1; i <= num / i; i++) {
            if (i * i == num) {
                return true;
            }
        }
        return false;
    }
}

16. You are given a 0-indexed array of strings details. Each element of details provides information about a given passenger compressed into a string of length 15. The system is such that:
The first ten characters consist of the phone number of passengers.
The next character denotes the gender of the person.
The following two characters are used to indicate the age of the person.
The last two characters determine the seat allotted to that person.
Return the number of passengers who are strictly more than 60 years old.

class Solution {
    public int countSeniors(String[] details) {
        int count = 0;
        for (int i = 0; i < details.length; i++) {
            if (Integer.parseInt(details[i].substring(11, 13))  > 60) {
                count += 1;
            }
        }
        return count;
    }
}

17. A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.
Given a string s, return true if it is a palindrome, or false otherwise.

class Solution {
    public boolean isPalindrome(String s) {
        if (s.length() == 0) {
            return true;
        }
        String checked = s.replaceAll("[^a-zA-Z0-9]", "");
        checked = checked.toLowerCase();
        StringBuilder reversed = new StringBuilder(checked);
        String reversedStr = reversed.reverse().toString();
        return checked.equals(reversedStr);
    }
}

18. Given an array nums of size n, return the majority element.
The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.

 

class Solution {
    public int majorityElement(int[] nums) {
        Map<Integer, Integer> mapOfOccurences = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if (!mapOfOccurences.containsKey(nums[i])) {
                mapOfOccurences.put(nums[i], 1);
            } else {
                mapOfOccurences.put(nums[i], mapOfOccurences.get(nums[i]) + 1);
            }
        }
        int max = Integer.MIN_VALUE;
        int numToMajority = 0;
        for (Integer num : mapOfOccurences.keySet()) {
            if (mapOfOccurences.get(num) > max) {
                max = mapOfOccurences.get(num);
                numToMajority = num;
            }
        }
        return numToMajority;
        
    }
}

19. Given two strings s and t, return true if t is an anagram of s, and false otherwise.
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

class Solution {
    public boolean isAnagram(String s, String t) {
        Map<Character, Integer> mapOfAllLetters = new HashMap<>();
        Map<Character, Integer> mapOfAllLettersT = new HashMap<>();
        for (int i = 0; i < s.length(); i++) {
mapOfAllLetters.put(s.charAt(i), !mapOfAllLetters.containsKey(s.charAt(i)) ? 1 : mapOfAllLetters.get(s.charAt(i)) + 1);


        }
        for (int i = 0; i < t.length(); i++) {
mapOfAllLettersT.put(t.charAt(i), !mapOfAllLettersT.containsKey(t.charAt(i)) ? 1 : mapOfAllLettersT.get(t.charAt(i)) + 1);


        }
        return mapOfAllLetters.equals(mapOfAllLettersT);
    }
}

19. The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,
F(0) = 0, F(1) = 1
F(n) = F(n - 1) + F(n - 2), for n > 1.
Given n, calculate F(n).

class Solution {
    public int fib(int n) {
        int num1 = 0;
        int num2 = 1;
        int num3 = 0;

        for (int i = 0; i < n; i++) {
            num1 = num2;
            num2 = num3;
            num3 = num1 + num2;
        }
        return num3;
    }
}
