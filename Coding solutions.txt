LeetCode Problems
1.  Median of Two Arrays : Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.
The overall run time complexity should be O(log (m+n)).

Answer: 
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    //Get the length for the new merged array and create new array
        int mergedLength = nums1.length + nums2.length;
        int[] nums3 = new int[mergedLength];
        //Create copies of nums1 and nums2 and initialize them in your new array
        System.arraycopy(nums1, 0, nums3, 0, nums1.length);  
        System.arraycopy(nums2, 0, nums3, nums1.length, nums2.length); 
        double median = 0;
        Arrays.sort(nums3);
        //Calculate for median when it has one median value or two median values
        if (nums3.length % 2 == 0) {
    median = ((double)nums3[nums3.length/2] + (double)nums3[nums3.length/2 - 1])/2;
} else {
    median = (double) nums3[nums3.length/2];
        return median;
        }
    }
}


2. 3Sum : Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
Notice that the solution set must not contain duplicate triplets.

Answer:
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> listOfTriplets = new ArrayList<>();
        Set<String> checkForDuplicates = new HashSet<>();

        Arrays.sort(nums); // Sort the array to optimize duplicate checks

        for (int i = 0; i < nums.length - 2; i++) {
            int j = i + 1;
            int k = nums.length - 1;

            while (j < k) {
                int sum = nums[i] + nums[j] + nums[k];

                if (sum == 0) {
                    List<Integer> triplet = Arrays.asList(nums[i], nums[j], nums[k]);
                    String tripletString = triplet.toString(); // Convert triplet to a string

                    if (!checkForDuplicates.contains(tripletString)) {
                        checkForDuplicates.add(tripletString);
                        listOfTriplets.add(triplet);
                    }

                    j++;
                    k--;
                } else if (sum < 0) {
                    j++;
                } else {
                    k--;
                }
            }
        }

        return listOfTriplets;
    }
}

3. Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order

class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int j = 1; j < nums.length; j++) {
                if (nums[i] + nums[j] == target && i != j) {
                    return new int[] {i, j};
                }
            }

            }
            return new int[]{0};
        }

    }
    
4. Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.

 class Solution {
    public boolean containsDuplicate(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int num : nums) {
            if (set.contains(num)) {
                return true;
            }
            set.add(num);
        }
        return false;
    }
}
5. Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

class Solution {
    public int strStr(String haystack, String needle) {
        return haystack.indexOf(needle);
    }
}

6. Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.
You must implement a solution with a linear runtime complexity and use only constant extra space.

class Solution {
    public int singleNumber(int[] nums) {
        List<Integer> listNumbers = Arrays.stream(nums)
                .boxed()
                .collect(Collectors.toList());
        for (int i = 0; i < listNumbers.size(); i++) {
            if (listNumbers.indexOf(listNumbers.get(i)) == listNumbers.lastIndexOf(listNumbers.get(i))) {
                return listNumbers.get(i);
            }
        }
        return 0;
    }
}
