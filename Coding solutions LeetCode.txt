LeetCode Problems
1.  Median of Two Arrays : Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.
The overall run time complexity should be O(log (m+n)).

Answer: 
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    //Get the length for the new merged array and create new array
        int mergedLength = nums1.length + nums2.length;
        int[] nums3 = new int[mergedLength];
        //Create copies of nums1 and nums2 and initialize them in your new array
        System.arraycopy(nums1, 0, nums3, 0, nums1.length);  
        System.arraycopy(nums2, 0, nums3, nums1.length, nums2.length); 
        double median = 0;
        Arrays.sort(nums3);
        //Calculate for median when it has one median value or two median values
        if (nums3.length % 2 == 0) {
    median = ((double)nums3[nums3.length/2] + (double)nums3[nums3.length/2 - 1])/2;
} else {
    median = (double) nums3[nums3.length/2];
        return median;
        }
    }
}


2. 3Sum : Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
Notice that the solution set must not contain duplicate triplets.

Answer:
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> listOfTriplets = new ArrayList<>();
        Set<String> checkForDuplicates = new HashSet<>();

        Arrays.sort(nums); // Sort the array to optimize duplicate checks

        for (int i = 0; i < nums.length - 2; i++) {
            int j = i + 1;
            int k = nums.length - 1;

            while (j < k) {
                int sum = nums[i] + nums[j] + nums[k];

                if (sum == 0) {
                    List<Integer> triplet = Arrays.asList(nums[i], nums[j], nums[k]);
                    String tripletString = triplet.toString(); // Convert triplet to a string

                    if (!checkForDuplicates.contains(tripletString)) {
                        checkForDuplicates.add(tripletString);
                        listOfTriplets.add(triplet);
                    }

                    j++;
                    k--;
                } else if (sum < 0) {
                    j++;
                } else {
                    k--;
                }
            }
        }

        return listOfTriplets;
    }
}

3. Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order

Brute Force Approach: O(N^2)
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int j = 1; j < nums.length; j++) {
                if (nums[i] + nums[j] == target && i != j) {
                    return new int[] {i, j};
                }
            }

            }
            return new int[]{0};
        }

    }

O(N) Approach:
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> mapNums = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (mapNums.containsKey(complement)) {
                return new int[]{i, mapNums.get(complement)};
            } else {
                mapNums.put(nums[i], i);
            }
        }
        return new int[]{-1,-1};
    }
}
    
4. Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.

 class Solution {
    public boolean containsDuplicate(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int num : nums) {
            if (set.contains(num)) {
                return true;
            }
            set.add(num);
        }
        return false;
    }
}
5. Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

class Solution {
    public int strStr(String haystack, String needle) {
        return haystack.indexOf(needle);
    }
}

6. Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.
You must implement a solution with a linear runtime complexity and use only constant extra space.

class Solution {
    public int singleNumber(int[] nums) {
        List<Integer> listNumbers = Arrays.stream(nums)
                .boxed()
                .collect(Collectors.toList());
        for (int i = 0; i < listNumbers.size(); i++) {
            if (listNumbers.indexOf(listNumbers.get(i)) == listNumbers.lastIndexOf(listNumbers.get(i))) {
                return listNumbers.get(i);
            }
        }
        return 0;
    }
}

7. Write a function that takes the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).

public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        String binaryString = Integer.toBinaryString(n);

        String[] binaryStringArr = binaryString.split("");

        return (int) Arrays.stream(binaryStringArr).filter(val -> val.equals("1")).count();
    }
}

8. Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]). Return the running sum of nums.

class Solution {
    public int[] runningSum(int[] nums) {
        int a = 0;
        int[] sums = new int[nums.length];
        for (int i = 0; i < nums.length; i++) {
            sums[i] = a + nums[i];
            a = a + nums[i];
        }
        return sums;
    }
}

9. There is a programming language with only four operations and one variable X:

++X and X++ increments the value of the variable X by 1.
--X and X-- decrements the value of the variable X by 1.
Initially, the value of X is 0.

Given an array of strings operations containing a list of operations, return the final value of X after performing all the operations.

class Solution {
    public int finalValueAfterOperations(String[] operations) {
        int count = 0;
        for (int i = 0; i < operations.length; i++) {
            if (operations[i].contains("--")) {
                count -=1;
            } else {
                count +=1;
            }
        }
        return count;
    }
}

10. Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's such that j != i and nums[j] < nums[i].
Return the answer in an array.

class Solution {
    public int[] smallerNumbersThanCurrent(int[] nums) {
        int[] numSmalls = new int[nums.length];
        int count = 0;
        for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j < nums.length; j++) {
                if (nums[i] > nums[j]) {
                    count+=1;
                }
            }
            numSmalls[i] = count;
            count = 0;
        }
        return numSmalls;
    }
}

11. There are n kids with candies. You are given an integer array candies, where each candies[i] represents the number of candies the ith kid has, and an integer extraCandies, denoting the number of extra candies that you have.
Return a boolean array result of length n, where result[i] is true if, after giving the ith kid all the extraCandies, they will have the greatest number of candies among all the kids, or false otherwise.
Note that multiple kids can have the greatest number of candies.

class Solution {
    public List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {
        List<Boolean> listOfLargest = new ArrayList<>();
        int max = Arrays.stream(candies).max().orElse(0);
        for (int i = 0; i < candies.length; i++) {
            if (candies[i] + extraCandies >= max) {
                listOfLargest.add(true);
            } else {
                listOfLargest.add(false);
            }
        }
        return listOfLargest;
    }
}

12. You are given an m x n integer grid accounts where accounts[i][j] is the amount of money the i​​​​​​​​​​​th​​​​ customer has in the j​​​​​​​​​​​th​​​​ bank. Return the wealth that the richest customer has.
A customer's wealth is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum wealth.

class Solution {
    public int maximumWealth(int[][] accounts) {
        List<Integer> listOfAccounts = new ArrayList<>();
        for (int[] account : accounts) {
            listOfAccounts.add(Arrays.stream(account).reduce((a,b) -> a + b).orElse(0));
        }
        return Collections.max(listOfAccounts);
    }
}

13. You are given two positive integers n and k. A factor of an integer n is defined as an integer i where n % i == 0.
Consider a list of all factors of n sorted in ascending order, return the kth factor in this list or return -1 if n has less than k factors.

class Solution {
    public int kthFactor(int n, int k) {
        List<Integer>listOfFactors = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            if (n % i == 0) {
                listOfFactors.add(i);
            }
        }
            if (k > listOfFactors.size()) {
                return -1; // k is out of bounds
        }
         return listOfFactors.get(k - 1);
    }
}

14. Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.

class Solution {
 public static int addDigits(int num) {
        String[] nums = String.valueOf(num).split("");
        while (nums.length > 1) {
            nums = String.valueOf(Arrays.stream(nums).mapToInt(numInArr -> Integer.parseInt(numInArr)).sum()).split("");
        }
        return Integer.parseInt(String.join("", nums));
    }
}

15. Given a positive integer num, return true if num is a perfect square or false otherwise.
A perfect square is an integer that is the square of an integer. In other words, it is the product of some integer with itself.
You must not use any built-in library function, such as sqrt.

class Solution {
    public boolean isPerfectSquare(int num) {

        for (int i = 1; i <= num / i; i++) {
            if (i * i == num) {
                return true;
            }
        }
        return false;
    }
}

16. You are given a 0-indexed array of strings details. Each element of details provides information about a given passenger compressed into a string of length 15. The system is such that:
The first ten characters consist of the phone number of passengers.
The next character denotes the gender of the person.
The following two characters are used to indicate the age of the person.
The last two characters determine the seat allotted to that person.
Return the number of passengers who are strictly more than 60 years old.

class Solution {
    public int countSeniors(String[] details) {
        int count = 0;
        for (int i = 0; i < details.length; i++) {
            if (Integer.parseInt(details[i].substring(11, 13))  > 60) {
                count += 1;
            }
        }
        return count;
    }
}

17. A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.
Given a string s, return true if it is a palindrome, or false otherwise.

class Solution {
    public boolean isPalindrome(String s) {
        if (s.length() == 0) {
            return true;
        }
        String checked = s.replaceAll("[^a-zA-Z0-9]", "");
        checked = checked.toLowerCase();
        StringBuilder reversed = new StringBuilder(checked);
        String reversedStr = reversed.reverse().toString();
        return checked.equals(reversedStr);
    }
}

18. Given an array nums of size n, return the majority element.
The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.

 

class Solution {
    public int majorityElement(int[] nums) {
        Map<Integer, Integer> mapOfOccurences = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if (!mapOfOccurences.containsKey(nums[i])) {
                mapOfOccurences.put(nums[i], 1);
            } else {
                mapOfOccurences.put(nums[i], mapOfOccurences.get(nums[i]) + 1);
            }
        }
        int max = Integer.MIN_VALUE;
        int numToMajority = 0;
        for (Integer num : mapOfOccurences.keySet()) {
            if (mapOfOccurences.get(num) > max) {
                max = mapOfOccurences.get(num);
                numToMajority = num;
            }
        }
        return numToMajority;
        
    }
}

19. Given two strings s and t, return true if t is an anagram of s, and false otherwise.
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

class Solution {
    public boolean isAnagram(String s, String t) {
        Map<Character, Integer> mapOfAllLetters = new HashMap<>();
        Map<Character, Integer> mapOfAllLettersT = new HashMap<>();
        for (int i = 0; i < s.length(); i++) {
mapOfAllLetters.put(s.charAt(i), !mapOfAllLetters.containsKey(s.charAt(i)) ? 1 : mapOfAllLetters.get(s.charAt(i)) + 1);


        }
        for (int i = 0; i < t.length(); i++) {
mapOfAllLettersT.put(t.charAt(i), !mapOfAllLettersT.containsKey(t.charAt(i)) ? 1 : mapOfAllLettersT.get(t.charAt(i)) + 1);


        }
        return mapOfAllLetters.equals(mapOfAllLettersT);
    }
}

20. The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,
F(0) = 0, F(1) = 1
F(n) = F(n - 1) + F(n - 2), for n > 1.
Given n, calculate F(n).

class Solution {
    public int fib(int n) {
        int num1 = 0;
        int num2 = 1;
        int num3 = 0;

        for (int i = 0; i < n; i++) {
            num1 = num2;
            num2 = num3;
            num3 = num1 + num2;
        }
        return num3;
    }
}

21. Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it.
You must implement a solution with a linear runtime complexity and use only constant extra space.

class Solution {
    public int singleNumber(int[] nums) {
        List<Integer> listOfNums = Arrays.stream(nums).boxed().collect(Collectors.toList());
        for (int i = 0; i < listOfNums.size(); i++) {
            if (listOfNums.indexOf(listOfNums.get(i)) == listOfNums.lastIndexOf(listOfNums.get(i))) {
                return listOfNums.get(i);
            }
        }

        return 0;
    }
}

22. Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.

class Solution {
    public int missingNumber(int[] nums) {
        Arrays.sort(nums);
        for (int i = 0; i < nums.length; i++) {
            if(nums[i] != i) return i;
        }
        return nums.length;
    }
}

23. Given an array of integers arr, a lucky integer is an integer that has a frequency in the array equal to its value.
Return the largest lucky integer in the array. If there is no lucky integer return -1.

class Solution {
    public int findLucky(int[] arr) {
        Map<Integer, Integer> allInts = new HashMap<>();
        List<Integer> luckyValues = new ArrayList<>();
        for (int i = 0; i < arr.length; i++) {
            if (!allInts.containsKey(arr[i])) {
                allInts.put(arr[i], 1);
            } else {
                allInts.put(arr[i], allInts.get(arr[i]) + 1);
            }
        }
        for (Integer val : allInts.keySet()) {
            if (allInts.get(val) == val) {
                 luckyValues.add(val);
            }
        }
        return luckyValues.size() > 0 ? Collections.max(luckyValues) : -1;

    }
}

24. Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.
You must write an algorithm that runs in O(n) time and uses only constant extra space.

class Solution {
    public List<Integer> findDuplicates(int[] nums) {
        Map<Integer,Integer> mapOfDuplicates = new HashMap<>();
        List<Integer> listOfTwos = new ArrayList<>();
        for (int i = 0; i < nums.length; i++) {
            if (!mapOfDuplicates.containsKey(nums[i])) {
                mapOfDuplicates.put(nums[i], 1);
            } else {
                mapOfDuplicates.put(nums[i], mapOfDuplicates.get(nums[i]) + 1);
            }

        }
        for (Integer num : mapOfDuplicates.keySet()) {
            if (mapOfDuplicates.get(num) == 2) {
                listOfTwos.add(num);
            }
        }
        return listOfTwos;
    }
}

25. A sentence is a list of words that are separated by a single space with no leading or trailing spaces.
You are given an array of strings sentences, where each sentences[i] represents a single sentence.
Return the maximum number of words that appear in a single sentence.

class Solution {
    public int mostWordsFound(String[] sentences) {
        return Arrays.stream(sentences).mapToInt(el -> el.split(" ").length).max().orElse(0);
    }
}

26. There is a malfunctioning keyboard where some letter keys do not work. All other keys on the keyboard work properly.
Given a string text of words separated by a single space (no leading or trailing spaces) and a string brokenLetters of all distinct letter keys that are broken, return the number of words in text you can fully type using this keyboard.

class Solution {
    public int canBeTypedWords(String text, String brokenLetters) {
        if (brokenLetters.length() == 0) {
            return text.split(" ").length;
        }
        String[] textArr = text.split(" ");
        String[] chars = brokenLetters.split("");
        return (int) Arrays.stream(textArr).filter(word -> Arrays.stream(chars).noneMatch(word::contains)).count();
    }
}

27. Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int subLength = p.length();
        List<Integer> listOfAnagram = new ArrayList<>();
                char[] charsp = p.toCharArray();
                Arrays.sort(charsp);
                char[] charsub;
        for (int i = 0; i < s.length(); i++) {
            if (i + subLength <= s.length()) {
                charsub = s.substring(i, i + subLength).toCharArray();
                Arrays.sort(charsub);
                if (Arrays.equals(charsub,charsp)) {
                    listOfAnagram.add(i);
                }
        }
     }
             return listOfAnagram;
    }
}

28. A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in non-decreasing order by height. Let this ordering be represented by the integer array expected where expected[i] is the expected height of the ith student in line.
You are given an integer array heights representing the current order that the students are standing in. Each heights[i] is the height of the ith student in line (0-indexed).
Return the number of indices where heights[i] != expected[i].

class Solution {
    public int heightChecker(int[] heights) {
        int wrong = 0;
        int[] expected = Arrays.copyOf(heights, heights.length);
        Arrays.sort(expected);
        for (int i = 0; i < heights.length; i++) {
            if (heights[i] != expected[i]) {
                wrong+=1;
            }
        }
        return wrong;
    }
}

29. Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.
Return any array that satisfies this condition.

class Solution {
    public int[] sortArrayByParity(int[] nums) {
        int[] parityArr = new int[nums.length];
        int indexE = 0;
        int indexO = nums.length - 1;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] % 2 == 0) {
                parityArr[indexE] = nums[i];
                indexE+=1;
            } else {
                parityArr[indexO] = nums[i];
                indexO -= 1;
            }
            
        }
        return parityArr;
        
    }
}

30. Given an array of integers nums, half of the integers in nums are odd, and the other half are even.
Sort the array so that whenever nums[i] is odd, i is odd, and whenever nums[i] is even, i is even.
Return any answer array that satisfies this condition.

class Solution {
    public int[] sortArrayByParityII(int[] nums) {
        int[] parityArr = new int[nums.length];
        int evenIndex = 0;
        int oddIndex = 1;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] % 2 == 0) {
                parityArr[evenIndex] += nums[i];
                evenIndex += 2;
            } else {
                parityArr[oddIndex] += nums[i];
                oddIndex += 2;
            }
        }
        return parityArr;

    }
}

31. Given a roman numeral, convert it to an integer.

class Solution {
    public int romanToInt(String str) {
        int acc = 0;
        int i = 0;
        while (i < str.length()) {

            if (i + 1 < str.length() && str.charAt(i) == 'I' && str.charAt(i+1) == 'V') {
                acc += 4;
                i+=2;
            } else if (i + 1 < str.length() && str.charAt(i) == 'X' && str.charAt(i+1) == 'L') {
                acc += 40;
                i+=2;
            } else if (i + 1 < str.length() && str.charAt(i) == 'I' && str.charAt(i+1) == 'X') {
                acc += 9;
                i+=2;
            } else if (i + 1 < str.length() && str.charAt(i) == 'X' && str.charAt(i+1) == 'C') {
                acc += 90;
                i+=2;
            } else if (i + 1 < str.length() && str.charAt(i) == 'C' && str.charAt(i+1) == 'D') {
                acc += 400;
                i+=2;
            } else if (i + 1 < str.length() && str.charAt(i) == 'C' && str.charAt(i+1) == 'M') {
                acc += 900;
                i+=2;
            } else if (str.charAt(i) == 'I') {
                acc += 1;
                i += 1;
            } else if (str.charAt(i) == 'V') {
                acc += 5;
                i += 1;
            } else if (str.charAt(i) == 'X') {
                acc += 10;
                i += 1;
            } else if (str.charAt(i) == 'L') {
                acc += 50;
                i += 1;
            } else if (str.charAt(i) == 'C') {
                acc += 100;
                i += 1;
            } else if (str.charAt(i) == 'D') {
                acc += 500;
                i += 1;
            } else if (str.charAt(i) == 'M') {
                acc += 1000;
                i += 1;
                }
            }
        
        return acc;
    }
}

32. Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.
There is only one repeated number in nums, return this repeated number.
You must solve the problem without modifying the array nums and uses only constant extra space.

class Solution {
    public int findDuplicate(int[] nums) {
        Map<Integer, Integer> mapOfNum = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if (!mapOfNum.containsKey(nums[i])) {
                mapOfNum.put(nums[i], 1);
            } else {
                return nums[i];
            }
        }
        return -1;
    }
}

33. Given two binary strings a and b, return their sum as a binary string.

import java.util.*;
import java.math.BigInteger;
class Solution {
    public String addBinary(String a, String b) {
        BigInteger val1 = new BigInteger(a, 2);
        BigInteger val2 = new BigInteger(b, 2);
        BigInteger sum = val1.add(val2);
        return sum.toString(2);

    }
}

34. Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.
You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.

import java.util.*;
class Solution {
    public int[] singleNumber(int[] nums) {
        Map<Integer, Integer> mapOfNums = new HashMap<>();
        int[] arr = new int[2];
        int j = 0;
        for (int i = 0; i < nums.length; i++) {
            if (!mapOfNums.containsKey(nums[i])) {
                mapOfNums.put(nums[i], 1);
            } else {
                mapOfNums.put(nums[i], mapOfNums.get(nums[i]) + 1);
            }
        }
        for (Integer num : mapOfNums.keySet()) {
            if (mapOfNums.get(num) == 1) {
                arr[j] = num;
                j += 1;
            }
        }
        return arr;
    }
}

35. Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.

class Solution {
    public int firstUniqChar(String s) {
        for (int i = 0; i < s.length(); i++) {
            if (s.lastIndexOf(s.charAt(i)) == s.indexOf(s.charAt(i))) {
                return i;
            }
        }
        return -1;
    }
}

36. You are given a string s representing an attendance record for a student where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:

'A': Absent.
'L': Late.
'P': Present.
The student is eligible for an attendance award if they meet both of the following criteria:

The student was absent ('A') for strictly fewer than 2 days total.
The student was never late ('L') for 3 or more consecutive days.
Return true if the student is eligible for an attendance award, or false otherwise.

class Solution {
    public boolean checkRecord(String s) {
        int absentCount = 0;
        int lateCount = 0;

        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == 'A') {
                absentCount +=1;
            }
            if (s.charAt(i) == 'L') {
                int j = i;
                while (j < s.length() && s.charAt(j) == 'L') {
                    lateCount += 1;
                    j += 1;
                }
                if (lateCount >= 3) {
                    return false;
                }
                lateCount = 0;
            }
        }
        return absentCount >= 2 ? false : true;
    }
}

37. You are given two 0-indexed integer arrays nums and divisors.
The divisibility score of divisors[i] is the number of indices j such that nums[j] is divisible by divisors[i].
Return the integer divisors[i] with the maximum divisibility score. If there is more than one integer with the maximum score, return the minimum of them.

import java.util.*;
class Solution {
    public int maxDivScore(int[] nums, int[] divisors) {
        Map<Integer,Integer> listOfVals = new HashMap<>();
        for (int i = 0; i < divisors.length; i++) {
            listOfVals.put(divisors[i], 0);
            for (int j = 0; j < nums.length; j++) {
                if (nums[j] % divisors[i] == 0) {
                    listOfVals.put(divisors[i], listOfVals.get(divisors[i]) + 1);
                }
            }
        }
        int max = Integer.MIN_VALUE;
        int divisor = 0;
        for (Integer val : listOfVals.keySet()) {

            if (listOfVals.get(val) > max || listOfVals.get(val) == listOfVals.get(divisor) && val < divisor) {
                max = listOfVals.get(val);
                divisor = val;
            }
        }
        return divisor;
    }
}

38. Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.

class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        if (head == null) {
            return null;
        }
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode previousNode = dummy;
        for (int i = 0; i < left - 1; i++) {
            previousNode = previousNode.next;
        }
        ListNode current = previousNode.next;
        for (int i = 0; i < right - left; i++) {
            ListNode temp = current.next;
            current.next = temp.next;
            temp.next = previousNode.next;
            previousNode.next = temp;
        }
        head = dummy.next;
        return head;
    }
}

39. Given the head of a singly linked list, return true if it is a 
palindrome or false otherwise.

class Solution {
    public boolean isPalindrome(ListNode head) {
        List<Integer> listForPalindrome = new ArrayList<>();

        while (head != null) {
            listForPalindrome.add(head.val);
            head = head.next;
        }
        List<Integer> listReverse = new ArrayList<>(listForPalindrome);
        Collections.reverse(listReverse);
        return listForPalindrome.equals(listReverse) ? true : false;
    }
}

40. There is a singly-linked list head and we want to delete a node node in it.
You are given the node to be deleted node. You will not be given access to the first node of head.
All the values of the linked list are unique, and it is guaranteed that the given node node is not the last node in the linked list.

class Solution {
    public void deleteNode(ListNode node) {
        node.val = node.next.val;
        node.next = node.next.next;
    }
}

41. Given the head of a linked list, remove the nth node from the end of the list and return its head.

class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode fast = dummy;
        ListNode slow = dummy;
        ListNode slowPrev = head;
        for (int i = 0; i <= n; i++) {
            fast = fast.next;
        }
        while (fast != null) {
            fast = fast.next;
            slow = slow.next;
        }
        slow.next = slow.next.next;
        return dummy.next;
    }
}

42. Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.

class Solution {
    public ListNode deleteDuplicates(ListNode head) {
    Map<Integer, Integer> mapDuplicates = new HashMap<>();
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode current = dummy.next;
    ListNode prev = dummy;

    while (current != null) {
        if (!mapDuplicates.containsKey(current.val)) {
            mapDuplicates.put(current.val, 1);
            prev = current;
        } else {
            prev.next = current.next;
        }
        current = current.next;
        }
    
    return dummy.next;
    }
}

43. You are climbing a staircase. It takes n steps to reach the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

class Solution {
    public int climbStairs(int n) {
        int[] arrayOfSteps = new int[n + 1];
        arrayOfSteps[0] = 1;
        arrayOfSteps[1] = 1;

        for (int i = 2; i <= n; i++) {
            arrayOfSteps[i] = arrayOfSteps[i - 1] + arrayOfSteps[i - 2];
        }
        return arrayOfSteps[n];
    }
}

44. Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.

class Solution {
    public boolean uniqueOccurrences(int[] arr) {
        Map<Integer, Integer> map = new HashMap<>();

        for (int i = 0; i < arr.length; i++) {
            if (!map.containsKey(arr[i])) {
                map.put(arr[i], 1);
            } else {
                map.put(arr[i], map.get(arr[i]) + 1);
            }
        }
        Set<Integer> set = new HashSet(map.values());
        return map.size() == set.size();
    }
}

45. You are given an array of strings names, and an array heights that consists of distinct positive integers. Both arrays are of length n.
For each index i, names[i] and heights[i] denote the name and height of the ith person.
Return names sorted in descending order by the people's heights.

class Solution {
    public String[] sortPeople(String[] names, int[] heights) {
        Map<Integer, String> mapOfHeights = new HashMap<>();
        for (int i = 0; i < names.length; i++) {
            mapOfHeights.put(heights[i], names[i]);
        }
        String[] people = new String[heights.length];
        List<Integer> listOfNums = new ArrayList<>(mapOfHeights.keySet());
        listOfNums.sort(Collections.reverseOrder());
        for (int i = 0; i < heights.length; i++) {
            people[i] = mapOfHeights.get(listOfNums.get(i));
        }
        return people;
    }
}

46. You are given an integer array nums. A number x is lonely when it appears only once, and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.
Return all lonely numbers in nums. You may return the answer in any order.

class Solution {
    public List<Integer> findLonely(int[] nums) {
        List<Integer> listOfTheLonely = new ArrayList<>();
        Map<Integer, Integer> mapOfAllNums = new HashMap<>();

        for (int num : nums) {
            mapOfAllNums.put(num, mapOfAllNums.getOrDefault(num, 0) + 1);
        }

        for (Integer val : mapOfAllNums.keySet()) {
            if (mapOfAllNums.get(val) == 1 && !mapOfAllNums.containsKey(val - 1) && !mapOfAllNums.containsKey(val + 1)) {
                listOfTheLonely.add(val);
            }
        }
        return listOfTheLonely;
    }
}

47. Given an integer array arr, return true if there are three consecutive odd numbers in the array. Otherwise, return false.

class Solution {
    public boolean threeConsecutiveOdds(int[] arr) {
        int oddCount = 0;
        for (int i = 0; i < arr.length; i++) {
            if (i + 2 < arr.length && arr[i] % 2 != 0 && arr[i+1] % 2 != 0 && arr[i+2] % 2 != 0) {
                return true;
            }
        }
        return false;
    }
}

48. You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.
Merge nums1 and nums2 into a single array sorted in non-decreasing order.

class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        for (int i = 0; i < nums1.length; i++) {
            for (int j = 0; j < nums2.length; j++) {
                if (nums1[i] == 0 && nums2[j] != 0) {
                    nums1[i] = nums2[j];
                    nums2[j] = 0;
                }
            }
        }
        Arrays.sort(nums1);
    }
}

49. Write an algorithm to determine if a number n is happy.
A happy number is a number defined by the following process:
Starting with any positive integer, replace the number by the sum of the squares of its digits.
Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.
Those numbers for which this process ends in 1 are happy.
Return true if n is a happy number, and false if not.

class Solution {
    public boolean isHappy(int n) {
                while (n != 1 && n != 4) {
            String val = String.valueOf(n);
            String[] split = val.split("");
            n = 0;
            for (int i = 0; i < split.length; i++) {
                n += Integer.parseInt(split[i]) * Integer.parseInt(split[i]);
            }
        }
        return n == 1;
        }
    }

50. You are given a 0-indexed array of positive integers nums. Find the number of triplets (i, j, k) that meet the following conditions:

0 <= i < j < k < nums.length
nums[i], nums[j], and nums[k] are pairwise distinct.
In other words, nums[i] != nums[j], nums[i] != nums[k], and nums[j] != nums[k].

class Solution {
    public int unequalTriplets(int[] nums) {
        Set<List<Integer>> noDupeTriplets = new HashSet<>();
        List<List<Integer>> allTriplets = new ArrayList<>();
        List<Integer>listOfNums = new ArrayList<>();
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                for (int k = j + 1; k < nums.length; k++) {
                    listOfNums.add(i);
                    listOfNums.add(j);
                    listOfNums.add(k);
                    if (!noDupeTriplets.contains(listOfNums) && nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) {
                        allTriplets.add(listOfNums);                  
                    }
                    listOfNums = new ArrayList<>();
                }
            }
        }
        return allTriplets.size();
    }
}

51. The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.
For example, The integer 5 is "101" in binary and its complement is "010" which is the integer 2.
Given an integer num, return its complement.

class Solution {
    public int findComplement(int num) {
        String binaryString = Integer.toBinaryString(num);
        String oppositeBinary = "";

        for (int i = 0; i < binaryString.length(); i++) {
            if (binaryString.charAt(i) == '1') {
                oppositeBinary += '0';
            } else {
                oppositeBinary += '1';
            }
        }
        return Integer.parseInt(oppositeBinary, 2);
        
    }
}

52. Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.
Letters are case sensitive, for example, "Aa" is not considered a palindrome here.

 

class Solution {
    public int longestPalindrome(String s) {
        if (s.length() == 1) {
            return 1;
        }
        Map<Character, Integer> mapOfChars = new HashMap<>();

        for (int i = 0; i < s.length(); i++) {
            if (!mapOfChars.containsKey(s.charAt(i))) {
                mapOfChars.put(s.charAt(i), 1);
            } else {
                mapOfChars.put(s.charAt(i), mapOfChars.get(s.charAt(i)) + 1);
            }
        }
        int count = 0;
        for (Character ch : mapOfChars.keySet()) {
                count += mapOfChars.get(ch) / 2 * 2;
            if (count % 2 == 0 && mapOfChars.get(ch) % 2 == 1) {
                count += 1;
            }
        }
        return count;
    
    }
}

53. Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Every close bracket has a corresponding open bracket of the same type.

class Solution {
    public boolean isValid(String s) {
        if (s.length() % 2 != 0) return false;
        Stack<Character> stack = new Stack();

        for (char ch : s.toCharArray()) {
            if (ch == '(' || ch == '{' || ch == '[') {
                stack.push(ch);
            } else if (ch == ')' && !stack.isEmpty() && stack.peek() == '(') {
                stack.pop();
            } else if (ch == '}' && !stack.isEmpty() && stack.peek() == '{') {
                stack.pop();
            } else if (ch == ']' && !stack.isEmpty() && stack.peek() == '[') {
                stack.pop();
            } else {
                return false;
            }
        }
        return stack.isEmpty();
    }
}

54. Given a string, write a function to check if it is a permutation of a palindrome.

    public boolean permutationPalindrome(String s) {
        Map<Character, Integer> charMap = new HashMap<>();
        s = s.replace(" ", "").toLowerCase();
        for (char ch : s.toCharArray()) {
                ch = Character.toLowerCase(ch);
                charMap.put(ch, charMap.getOrDefault(ch, 0) + 1);
        }

        int oddCount = 0;
        for (int count : charMap.values()) {
            if (count % 2 == 1) {
                oddCount++;
            }
        }

        return oddCount <= 1;
    }

55. One Edit Away

    boolean oneEditAway(String first, String second) {
        if (first.length() == second.length()) {
            return oneEditReplace(first, second);
        } else if (first.length() - 1 == second.length()) {
            return oneEditInsert(first, second);
        } else if (first.length() + 1 == second.length()) {
            return oneEditInsert(first,second);
        }
        return false;
    }
    boolean oneEditReplace(String first, String second) {
        boolean differenceFound = false;
        for (int i = 0; i < first.length(); i++) {
            if (first.charAt(i) != second.charAt(i)) {
                if (differenceFound) {
                    return false;
                }
                differenceFound = true;
            }
        }
        return true;
    }


    boolean oneEditInsert(String first, String second) {
        int index1 = 0;
        int index2 = 0;
        while (index2 < second.length() && index1 < first.length()) {
            if (first.charAt(index1) != second.charAt(index2)) {
                if (index1 != index2) {
                    return false;
            }
            index2++;
        } else {
            index1++;
            index2++;
            }
        }
        return true;
    }

56. 4Sum Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:
Explanation: Utilize 3sum logic into 4 sum O(N^3)
class Solution {
        public static List<List<Integer>> fourSum(int[] nums, int target) {
            Arrays.sort(nums);
            List<List<Integer>> listOf4Sum = new ArrayList<>();
            
            for (int i = 0; i < nums.length; i++) {
                if (i == 0 || i > 0 && nums[i] != nums[i - 1]) {
                long sumToFindTriplet = target - (long)nums[i];
                for (int j = i + 1; j < nums.length; j++) {
                    if (j == i + 1 || j > 1 && nums[j] != nums[j - 1]) {
                    long complement = sumToFindTriplet - (long)nums[j];
                    int start = j + 1;
                    int end = nums.length - 1;
                    while (start < end) {
                        if ((long)nums[start] + (long)nums[end] == complement) {
                            listOf4Sum.add(Arrays.asList(nums[i], nums[j], nums[start], nums[end]));
                            while(start < end && nums[start] == nums[start+1]) start++;
                            while (start < end && nums[end] == nums[end - 1]) end--;
                            start++;
                            end--;
                        } else if (nums[start] + nums[end] > complement) {
                            end--;
                        } else {
                            start++;
                        }
                    }
                    }
                }
                }

            }
            return listOf4Sum;
        
    }
}

57. Generate Parentheses (Backtrack problem) Permututations

class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> list = new ArrayList<>();
        backtrack("", 0, 0, n, list);
        return list;
    }

    public void backtrack (String current, int open, int close, int max, List<String> list) {
        if (current.length() == max * 2) {
            list.add(current);
            return;
        }

        if (open < max) {
            backtrack(current + "(", open + 1, close, max, list);
        }
        if (close < open) {
            backtrack(current + ")", open, close + 1, max, list);
        }
    }
}

58. Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.
A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
Backtrack solution:

class Solution {
    public List<String> letterCombinations(String digits) {
        Map<Integer, String> mapOfPhone = new HashMap<>();
        List<String> list = new ArrayList<>();
        if (digits.length() == 0) return list;
        mapOfPhone.put(2, "abc");
        mapOfPhone.put(3, "def");
        mapOfPhone.put(4, "ghi");
        mapOfPhone.put(5, "jkl");
        mapOfPhone.put(6, "mno");
        mapOfPhone.put(7, "pqrs");
        mapOfPhone.put(8, "tuv");
        mapOfPhone.put(9, "wxyz");
        backtrack(mapOfPhone, 0, "", list, digits);
        return list;
    }

            public void backtrack (Map<Integer, String> map, int index, String str, List<String> list, String digits) {
            if (str.length() == digits.length()) {
              list.add(str);
              return;
            }
            int digit = Character.getNumericValue(digits.charAt(index));
            for (int j = 0; j < map.get(digit).length(); j++) {
            backtrack(map, index + 1, str + map.get(digit).charAt(j), list, digits);
            }
        }
}

59. Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.

class Solution {
    public void rotate(int[] nums, int k) {
        k = k % nums.length;
        reverse(nums, 0, nums.length - 1); // reverse whole array [7,6,5,4,3,2,1]
        reverse(nums, 0, k - 1); // reverse first k numbers
        reverse(nums, k, nums.length - 1); // reverse numbers after k numbers
    }
    public void reverse(int[] nums, int start, int end) {
        while (start < end) {
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start++;
            end--;
        }
    }
}

60. Given an array of positive integers nums and a positive integer target, return the minimal length of a 
subarray
 whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.
Window Sliding Technique
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int left = 0;
        int total = 0;
        int minLength = Integer.MAX_VALUE;

        for (int right = 0; right < nums.length; right++) {
            total += nums[right];
            while (total >= target) {
                minLength = Math.min(right - left + 1, minLength);
                total -= nums[left];
                left += 1;
            }
        }
        return minLength == Integer.MAX_VALUE ? 0 : minLength;

    }
}

61. Given a string s, find the length of the longest 
substring without repeating characters.
Window Sliding Technique

class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int left = 0;
        int max = 0;
        for (int right = 0; right < s.length(); right++) {
            while (set.contains(s.charAt(right))) {
                set.remove(s.charAt(left));
                left++;
            }
            set.add(s.charAt(right));
            max = Math.max(max, right - left + 1);
        }
        return max;
    }
}

62. Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.
(Backtracking problem)

class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> listOfLists = new ArrayList<>();
        backtrack(new ArrayList<>(), nums, listOfLists);
        return listOfLists;
    }

    public void backtrack(List<Integer> current, int[] nums, List<List<Integer>> listOfLists) {
        if (current.size() == nums.length) {
            listOfLists.add(new ArrayList<>(current));
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            if (current.contains(nums[i])) continue;
            current.add(nums[i]);
            backtrack(current, nums, listOfLists);
            current.remove(current.size() - 1);
        }
    }

}

63. Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.
The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the 
frequency
 of at least one of the chosen numbers is different.
The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.

class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> listOfLists = new ArrayList<>();
        backtrack(listOfLists, new ArrayList<>(), target, candidates, 0, 0);
        return listOfLists;
    }
    public void backtrack(List<List<Integer>> listOfLists, List<Integer> currentList, int target, int[] candidates, int startIndex, int currentListTotal) {
        if (currentListTotal == target) {
            listOfLists.add(new ArrayList<>(currentList));
            return;
        }

        for (int i = startIndex; i < candidates.length; i++) {
            if (candidates[i] + currentListTotal > target) {
                continue;
            }
            currentList.add(candidates[i]);
            backtrack(listOfLists, currentList, target, candidates, i, currentListTotal + candidates[i]);
            currentList.remove(currentList.size() - 1);
        }
    }
}

64. Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.
Return the sum of the three integers.
You may assume that each input would have exactly one solution.

class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int minVal = Integer.MAX_VALUE;
        for (int i = 0; i < nums.length; i++) {
            if (i == 0 || i > 0 && nums[i] != nums[i - 1]) {
            int start = i + 1;
            int end = nums.length - 1;
            while (start < end) {
                int sum = nums[i] + nums[start] + nums[end];
                if (Math.abs(target - sum) < Math.abs(target - minVal)) {
                    minVal = sum;
                }
                if (sum < target) {
                    start++;
                } else if (sum > target) {
                    end--;
                } else {
                    return target;
                }
            }
            }
        }
        return minVal;        
    
    }
}

65. Given an integer array nums, find the 
subarray
 with the largest sum, and return its sum.
(Optimal Solution using Kadane's Algorithm)
class Solution {
    public int maxSubArray(int[] nums) {
        int max = nums[0];
        int current = 0;
        for (int num : nums) {
            current = Math.max(current, 0);
            current += num;
            max = Math.max(max, current);
        }
        return max;
    }
}

66. You are given an integer array nums consisting of n elements, and an integer k.
Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10-5 will be accepted.
(Window Sliding Technique) 
class Solution {
    public double findMaxAverage(int[] nums, int k) {
        int left = 0;
        double total = 0;
        int length = 0;
        double maximum = Integer.MIN_VALUE;

        for (int right = 0; right < nums.length; right++) {
            total += nums[right];
            length++;
            if (length >= k) {
                maximum = Math.max(maximum, total);
                total -= nums[left];
                left++;
                length--;
            }
        }
        return maximum / k;
    }
}

